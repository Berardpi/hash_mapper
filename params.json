{"name":"Hash mapper","body":"# hash_mapper\r\n\r\n* http://github.com/ismasan/hash_mapper\r\n\r\n## DESCRIPTION:\r\n\r\nMaps values from hashes with different structures and/or key names. Ideal for normalizing arbitrary data to be consumed by your applications, or to prepare your data for different display formats (ie. json).\r\n \r\nTiny module that allows you to easily adapt from one hash structure to another with a simple declarative DSL.\r\n\r\n## FEATURES/PROBLEMS:\r\n\r\nIt is a module so it doesn't get in the way of your inheritance tree.\r\n\r\n## SYNOPSIS:\r\n\r\n```ruby\r\nclass ManyLevels\r\n  extend HashMapper\r\n  map from('/name'),            to('/tag_attributes/name')\r\n  map from('/properties/type'), to('/tag_attributes/type')\r\n  map from('/tagid'),           to('/tag_id')\r\n  map from('/properties/egg'),  to('/chicken')\r\nend\r\n\r\ninput = \t{\r\n  :name => 'ismael',\r\n  :tagid => 1,\r\n  :properties => {\r\n    :type => 'BLAH',\r\n    :egg => 33\r\n  }\r\n}\r\n\r\nManyLevels.normalize(input)\r\n\r\n# outputs:\r\n\t{\r\n  :tag_id => 1,\r\n  :chicken => 33,\r\n  :tag_attributes => {\r\n    :name => 'ismael',\r\n    :type => 'BLAH'\r\n  }\r\n}\r\n```\r\n\r\n### Uses:\r\n\r\nHashMapper was primarily written as a way of mapping data structure in json requests to hashes with structures friendlier to our ActiveRecord models:\r\n\r\n```ruby\r\n@article = Article.create( ArticleParams.normalize(params[:weird_article_data]) )\r\n```\r\n\r\nYou can use HashMapper in your own little hash-like objects:\r\n\r\n```ruby\r\nclass NiceHash\r\n  include Enumerable\r\n  extend HashMapper\r\n  \r\n  map from('/names/first'), to('/first_name')\r\n  map from('/names/last'), to('/last_name')\r\n\r\n  def initialize(input_hash)\r\n    @hash = self.class.normalize(input_hash)\r\n  end\r\n\r\n  def [](k)\r\n    @hash[k]\r\n  end\r\n\r\n  def []=(k,v)\r\n    @hash[k] = v\r\n  end\r\n\r\n  def each(&block)\r\n    @hash.each(&block)\r\n  end\r\nend\r\n\r\n@user = User.new(NiceHash.new(params))\r\n```\r\n\r\n### Options:\r\n\r\n#### Coercing values\r\n\r\nYou want to make sure an incoming value gets converted to a certain type, so \r\n\r\n```ruby\r\n{'one' => '1', 'two' => '2'}\r\n```\r\n\r\ngets translated to\r\n\r\n```ruby`\r\n{:one => 1, :two => 2}\r\n```\r\n\r\nDo this:\r\n\r\n```ruby\r\nmap from('/one'), to('/one', &:to_i)\r\nmap from('/two'), to('/two', &:to_i)\r\n```\r\n\r\nYou can pass :to_i, :to_s or anything available method that makes sense. Don't forget the block notation (&).\r\n\r\nYou guessed it. That means that you can actually pass custom blocks to each to() definition as well. The following is similar to the previous example:\r\n\r\n```ruby\r\nmap from('/one), to('/one'){|value| value.to_i}\r\n```\r\n\r\n#### Custom value filtering\r\n\r\nYou want to pass the final value of a key through a custom filter:\r\n\r\n```ruby\r\n{:names => {:first => 'Ismael', :last => 'Celis'}} gets translated to {:user => 'Mr. Celis, Ismael'}\r\n```\r\n\r\nDo this:\r\n\r\n```ruby\r\nmap from('/names'), to('/user') do |names|\r\n  \"Mr. #{names[1]}, #{names[0]}\"\r\nend\r\n```\r\n\r\n### Mapping in reverse\r\n\r\nCool, you can map one hash into another, but what if I want the opposite operation?\r\n\r\nJust use the denormalize() method instead:\r\n\r\n```ruby\r\ninput = {:first => 'Mark', :last => 'Evans'}\r\n\r\noutput = NameMapper.normalize(input) # => {:first_name => 'Mark', :last_name => 'Evans'}\r\n\r\nNameMapper.denormalize(output) # => input\r\n```\r\n\t\r\nThis will work with your block filters and even nested mappers (see below).\r\n\t\r\n### Advanced usage\r\n#### Array access\r\nYou want:\r\n\r\n```ruby\r\n{:names => ['Ismael', 'Celis']}\r\n```\r\n\r\nconverted to\r\n\r\n```ruby\r\n{:first_name => 'Ismael', :last_name => 'Celis'}\r\n```\r\n\r\nDo this:\r\n\r\n```ruby\r\nmap from('/names[0]'), to('/first_name')\r\nmap from('/names[1]'), to('/last_name')\r\n```\r\n\r\n#### Nested mappers\r\n\r\nYou want to map nested structures delegating to different mappers:\r\n\r\nFrom this:\r\n\r\n```ruby\r\ninput = {\r\n\t:project \t\t=> 'HashMapper',\r\n\t:url\t\t\t=> 'http://github.com/ismasan/hash_mapper',\r\n\t:author_names\t=> {:first => 'Ismael', :last => 'Celis'}\r\n}\r\n```\r\n\r\nTo this:\r\n\r\n```ruby\r\noutput = {\r\n\t:project_name\t=> 'HashMapper',\r\n\t:url\t\t\t=> 'http://github.com/ismasan/hash_mapper',\r\n\t:author\t\t\t=> {:first_name => 'Ismael', :last_name => 'Celis'}\r\n}\r\n```\r\n\r\nDefine an UserMapper separate from your ProjectMapper, so you reuse them combined or standalone\r\n\r\n```ruby\r\nclass UserMapper\r\n  extend HashMapper\r\n  map from('/first'),\tto('/first_name')\r\n  map from('/last'),\t\tto('/lastt_name')\r\nend\r\n\r\nclass ProjectMapper\r\n  extend HashMapper\r\n  map from('/project'), \t\tto('/project_name')\r\n  map from('/url'),\t\t\tto('/url')\r\n  map from('/author_names'),\tto('/author'), using(UserMapper)\r\nend\r\n```\r\n\r\nNow ProjectMapper will delegate parsing of :author_names to UserMapper\r\n\r\n```ruby\r\nProjectMapper.normalize( input ) # => output\r\n```\r\n\r\nLet's say you have a CompanyMapper which maps a hash with an array of employees, and you want to reuse UserMapper to map each employee. You could:\r\n\r\n```ruby\r\nclass CompanyMapper\r\n  map from('/info/name'), \t\t\tto('/company_name')\r\n  map form('/info/address'),\t\t\tto('/company_address')\r\n  map from('/info/year_founded'),\tto('year_founded', :to_i)\r\n\r\n  map from('/employees'),\t\t\tto('employees') do |employees_array|\r\n    employees_array.collect {|emp_hash| UserMapper.normalize(emp_hash)}\r\n  end\r\nend\r\n```\r\n\r\nBut HashMapper's nested mappers will actually do that for you if a value is an array, so:\r\n\r\n```ruby\t\r\nmap from('/employees'),\tto('employees'), using(UserMapper)\r\n```\r\n... Will map each employee using UserMapper.\r\n\r\n#### Before and after filters\r\n\r\nSometimes you will need some slightly more complex processing on the whole hash, either before or after normalizing/denormalizing.\r\n\r\nFor this you can use the class methods before_normalize, before_denormalize, after_normalize and after_denormalize.\r\n\r\nThey all yield a block with 2 arguments - the hash you are mapping from and the hash you are mapping to, e.g.\r\n\r\n```ruby\r\nclass EggMapper\r\n  map from('/raw'), to('/fried')\r\n  \r\n  before_normalize do |input, output|\r\n    input['raw'] ||= 'please'     # this will give 'raw' a default value \r\n    input\r\n  end\r\n  \r\n  after_denormalize do |input, output|\r\n    output.to_a        # the denormalized object will now be an array, not a hash!!\r\n  end\r\n\r\nend\r\n```\r\n\r\nImportant: note that for before filters, you need to return the (modified) input, and for after filters, you need to return the output.\r\nNote also that 'output' is correct at the time of the filter, i.e. before_normalize yields 'output' as an empty hash, while after_normalize yields it as an already normalized hash.\r\n\r\n   \r\n## REQUIREMENTS:\r\n\r\n## TODO:\r\n\r\n\r\n#### Optimizations\r\n\r\n* Get rid of ActiveSupport (used for inherited class variables and HashWithIndifferentAccess)\r\n\r\n## INSTALL:\r\n\r\n\r\n   gem install hash_mapper\r\n\r\n## Credits:\r\n\r\n* Ismael Celis (Author - http://www.estadobeta.com)\r\n* Mark Evans (Contributor - http://github.com/markevans)\r\n* Jdeveloper (Contributor - http://github.com/jdeveloper)\r\n* nightscape (Contributor - http://github.com/nightscape)\r\n* radamanthus (Contributor - http://github.com/radamanthus)\r\n\r\n## LICENSE:\r\n\r\n(The MIT License)\r\n\r\nCopyright (c) 2009 Ismael Celis\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining\r\na copy of this software and associated documentation files (the\r\n'Software'), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to\r\npermit persons to whom the Software is furnished to do so, subject to\r\nthe following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be\r\nincluded in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\r\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","tagline":"Tiny module that allows you to easily adapt from one hash structure to another with a simple declarative DSL.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}